#! /usr/bin/perl -w
use strict;

=head1 NAME

mkspifits.pl - create the spifits data to be used by addspi

=head1 SYNOPSIS

perl mkspifits.pl [options]

=head1 DESCRIPTION

Reads Brad's RDB files (those generated by genstats.pl, from which he
removes unilluminated regions). For each subtap, using the B, C, O and
Al data, the mean/median samp are divided by the average mean/median
in all above anodes and this the linear relation of this "normalized"
samp to log(E) is estimated. For the unilluminated regions the
background data are used and the intercept and slope are estimated
from the illuminated fits at the same CRSV subtap (see code for
details!). 

=head1 OPTIONS

=over 4

=item --help

Show help and exit.

=item --version

Show version and exit.

=back

=head1 AUTHOR

Pete Ratzlaff E<lt>pratzlaff@cfa.harvard.eduE<gt> June 2008

=head1 SEE ALSO

perl(1).

=cut

my $version = '0.1';

use FindBin;
use Config;
use Carp;
use PDL;
use PDL::Fit::Polynomial;
use PDL::Graphics::PGPLOT;
use PDL::IO::FITS;
use MyRDB;
use Lab;
use Data::Dumper;
use Astro::FITS::CFITSIO qw( TDOUBLE BINARY_TBL );
use IO::File;

use Getopt::Long;
my %default_opts = (
		    rdbdir => '/data/legs/rpete/cal/hrcs_gain/StatsData',
		    chip => 1,
		    iqr => 1,
		    iqrconst => 1.14,
		    trimmed => 1,
		    bgslope => 0.619,
		    bgintercept => 39.371,
		    dropdir => '/data/legs/rpete/cal/hrcs_gain/GainDrop',
		    stat => 'mean',
#		    outfile => 'spifits.fits',
#		    rdbfile => 'spifits.rdb',
		    );

my %opts = %default_opts;
GetOptions(\%opts,
	   'help!', 'version!', 'debug!',
	   'rdbdir=s', 'chip=i', 'iqrconst=f', 'iqr!', 'trimmed!',
	   'stat=s', 'outfile=s', 'rdbfile=s',
	   ) or die "Try --help for more information.\n";
if ($opts{debug}) {
  $SIG{__WARN__} = \&Carp::cluck;
  $SIG{__DIE__} = \&Carp::confess;
}
$opts{help} and _help();
$opts{version} and _version();

$opts{rdbfile} = "spi$opts{stat}fits.rdb" unless $opts{rdbfile};
$opts{outfile} = "spi$opts{stat}fits.fits" unless $opts{outfile};

# used for computation of background statistic in unilluminated_fits()
my %statfunc = (
		mean => \&Lab::hists_mean,
		median => \&Lab::hists_median,
		);

my %rdbext = (
	      mean => '',
	      median => '.med',
	      );

# from Brad's 2008-05-29 email
my %factors = (
	       mean =>   { B => 1.0268, O => 1.0139, },
	       median => { B => 1.0155, O => 1.0039,},
	      );

# relation between background mean/median and S_i, from Brad's 2008-06-02 email
my %bgparams = (
		mean =>   { slope => 0.619, intercept => 39.371 },
		median => { slope => 0.719, intercept => 19.054 },
	       );

# unilluminated b_i factor, from Brad's 2008-06-02 email
my %ufactor = (
	       mean =>   116.5 / 113.32,
	       median => 118.5 / 116.36,
	      );

my ($dates, $factors) = dropfactors($opts{dropdir});

my @anodes = qw( B C O Al );
my @energies = (183, 277, 525, 1487);
my $energies = pdl \@energies;

my $tmp;
my %data;

# average samp in each subtap from B, O, C and Al
my $S = zeroes(float, Lab::dims2d());

# uncertainty of average samps (not actually used anywhere?)
my $Serr = $S->copy;

# number of anodes that contributed to average samps
my $n = zeroes(long, Lab::dims2d());

for my $anode (@anodes) {

  $data{$anode}{stat} = zeroes($S);
  $data{$anode}{err} = zeroes($Serr);
  $data{$anode}{mask} = zeroes(long, $S->dims);

  for my $chip (1..3) {

    my $file = "$opts{rdbdir}/$anode$chip.rdb";
    print STDERR "reading $file...";
    my ($stat, $err, $mask) = rdb_data($file);
    print STDERR "done\n";

    my $i = whichND($mask);

    ($tmp = $data{$anode}{stat}->indexND($i)) .= $stat->indexND($i);
    ($tmp = $data{$anode}{err}->indexND($i)) .= $err->indexND($i);
    ($tmp = $data{$anode}{mask}->indexND($i)) .= 1;

  }

  my $i = whichND($data{$anode}{mask});

  if (exists $factors{$opts{stat}}{$anode}) {
    for (qw( stat err )) {
      (my $tmp = $data{$anode}{$_}->indexND($i)) *= $factors{$opts{stat}}{$anode};
    }
  }

  # update images of average means and errs
  ($tmp = $n->indexND($i))++;
  ($tmp = $S->indexND($i)) += $data{$anode}{stat}->indexND($i);
  ($tmp = $Serr->indexND($i)) += ($data{$anode}{err}->indexND($i))**2;
}

# make sure all anodes had the same coverage in RDB files
die if (which(($n!=0) & ($n!=@anodes))->nelem);
my $imask = $n==@anodes; # illuminated subtaps mask

# finish up average means
# FIXME: uncertainties here are not strictly correct, probably a good enough
#        estimate though?
my $i = whichND($imask);
($tmp = $S->indexND($i)) /= $n->indexND($i);
($tmp = $Serr->indexND($i)) = sqrt($Serr->indexND($i) / $n->indexND($i));

# renormalize the means for each anode
for (@anodes) {
  ($tmp = $data{$_}{stat}->indexND($i)) /= $S->indexND($i);
  ($tmp = $data{$_}{err}->indexND($i)) /= $S->indexND($i);
}

my $stats = cat( map { $data{$_}{stat} } @anodes )->mv(2,0);
my $errs = cat( map { $data{$_}{err} } @anodes )->mv(2,0);
my ($yfit, $coeffs) = fitpoly1d($energies->log10, $stats, 2, { Weights => 1/$errs/$errs });

my $intercept = $coeffs->slice('(0)');
my $slope = $coeffs->slice('(1)');

dev 'linear3.ps/ps', 2,2;
bin hist($intercept->indexND($i)), { xtitle => 'intercept' };
bin hist($slope->indexND($i)), { xtitle => 'slope' };
points $S->indexND($i), $intercept->indexND($i), { xtitle => "average SAMP $opts{stat}", ytitle => 'intercept' };
points $S->indexND($i), $slope->indexND($i), { xtitle => "average SAMP $opts{stat}", ytitle => 'slope' };

# double check that the RDB subtaps are the same as the "source"
# active mask
my $ams = Lab::active_mask_src();
my $diff = $ams->double - $imask->double;
$diff->max == $diff->min and $diff->max == 0 or die join(', ', $diff->stats);

my ($uS, $uintercept, $uslope, $umask) = unilluminated_fits($slope);

# incoporate unilluminated values into $S, $slope and $intercept
$i = whichND($umask);
($tmp = $S->indexND($i)) .= $uS->indexND($i);
($tmp = $slope->indexND($i)) .= $uslope->indexND($i);
($tmp = $intercept->indexND($i)) .= $uintercept->indexND($i);

# write everything
write_spifits($opts{outfile}, $S, $intercept, $slope, $dates, $factors);

# write RDB file for Brad
my ($nx, $ny) = Lab::dims2d();
my $ucoord = xvals( long, $nx, $ny );
my $vcoord = yvals( long, $nx, $ny );

my $vtap = $vcoord / 3;
my $utap = $ucoord / 3;

my $vsub = $vcoord % 3;
my $usub = $ucoord % 3;

{
  print STDERR "writing $opts{rdbfile}...";
  STDERR->flush;

  local $PDL::IO::Misc::colsep = '';
  my $i = which($slope==$slope);
  $_ = $_->flat->index($i) for $S, $slope, $intercept, $vtap, $utap, $vsub, $usub;
  wcols "%d\t%d\t%d\t%d\t%f\t%f\t%f",
    $vtap, $vsub, $utap, $usub, $S, $intercept, $slope,
    $opts{rdbfile},
    { header =>
      join("\t", qw( crsv vsub crsu usub S_i b_i m_i )) . "\n" .
      join("\t", ('N')x7)."\n"
    };

  print STDERR "done\n";
}

# double check some things
my $nomask = (!$umask) & (!$imask);
print $nomask->sum,"\n";
for ($S, $slope, $intercept) {
  print sum($_==0),"\n";
#  which($nomask & $_==0)->nelem or die;
}

exit 0;

sub _help {
  exec("$Config{installbin}/perldoc", '-F', $FindBin::Bin . '/' . $FindBin::RealScript);
}

sub _version {
  print $version,"\n";
  exit 0;
}

sub rdb_data {
  my $f = shift;

  my @cols = MyRDB::rdb_col_names($f) or die;

  my ($subs, $stat, $n, $rms, $err, $v, $vsub, $u, $usub);

  my $rmscol = $opts{iqr} ? 'siqr' : 'srms';
  my $statcol;

  for ($opts{stat}) {

    $_ eq 'median' and $statcol = 'smed', last;

    if ($_ eq 'mean') {
      $statcol = $opts{trimmed} ? 'stmean5' : 'smean';
      last;
    }

    die "statistic $opts{stat} unrecognized";
  }

  if (grep { $_ eq 'BG' } @cols) {
    my ($nnet, $bg);
    ($v, $vsub, $u, $usub, $subs, $n, $nnet, $bg, $stat, $rms) = MyRDB::rdb_cols($f, qw( crsv vsub crsu usub subs n nnet BG ), $statcol, $rmscol);
    $_ = pdl $_ for $stat, $n, $rms, $nnet, $bg;
    $rms /= $opts{iqrconst} if $opts{iqr};
    $err = $rms * sqrt($n+$bg) / $nnet;
  }
  else {
    ($v, $vsub, $u, $usub, $subs, $n, $stat, $rms) = MyRDB::rdb_cols($f, qw( crsv vsub crsu usub subs n), $statcol, $rmscol);
    $_ = pdl $_ for $stat, $n, $rms;
    $rms /= $opts{iqrconst} if $opts{iqr};
    $err = $rms / sqrt($n);
  }

  my %err_factors = (
		     '3x1' => sqrt(3),
		     '3x3' => 3,
		      );

  while (my ($v, $f) = each %err_factors) {
    my $index = long [ grep { $subs->[$_] eq $v } 0..$#{$subs} ];
    (my $tmp = $err->index($index)) *= $f if $index->nelem;
  }

  $_ = long $_ for $v, $vsub, $u, $usub;

  my $iu = $u * Lab::SUBTAPS() + $usub;
  my $iv = $v * Lab::SUBTAPS() + $vsub;
  my $i = cat($iu, $iv)->mv(1,0);

  my $stat_img = zeroes(float, Lab::dims2d());
  my $err_img = zeroes($stat_img);
  my $mask = zeroes(byte, $stat_img->dims);

  my $tmp;
  ($tmp = $stat_img->indexND($i)) .= $stat;
  ($tmp = $err_img->indexND($i)) .= $err;
  ($tmp = $mask->indexND($i)) .= 1;

  return $stat_img, $err_img, $mask;
}

sub dropfactors {
  my $dir = shift;

  opendir(DIR, $dir) or die;
  my @files = grep /^smooth[123]\.\d+$/, readdir DIR;
  closedir DIR;

  # get unique dates, sorted numnerically
  my %dates = map { /\.(\d+)/, 1 } @files;
  my @dates = sort { $a <=> $b } keys %dates;

  my (undef, $vsubs) = Lab::dims2d();

  my $dates = pdl(\@dates) / 10. ;
  my $factors = ones($dates->nelem, $vsubs);

  for my $chip (1..3) {

    # see 2008-08-08 email from Brad for explanation of extracorr factor
    my $extracorrfile = "$dir/extracorr$chip.out";
    my $extracorr = rcols $extracorrfile, 1,  { lines => '2:' };

    for my $i (0..$#dates) {
      my $date = $dates[$i];
      my $file = "$dir/smooth$chip.$date$rdbext{$opts{stat}}";

      my ($v, $factor) = rcols $file, { lines => '2:' };
      $factor /= $extracorr;

      # FIXME : assumes 3 subtaps
      my $tap = long($v);
      my $subtap = long(
			rint(
			     +(($v - $tap)+1/6) * 3
			    ) - 1
		       );
      my $coords = $tap * 3 + $subtap;

      (my $tmp = $factors->slice("($i)"));
      (my $tmp2 = $tmp->index($coords)) .= $factor;
    }
  }

  return $dates, $factors;
}

sub check_status {
  my $s = shift;
  if ($s != 0) {
    my $txt;
    Astro::FITS::CFITSIO::fits_get_errstatus($s,$txt);
    carp "CFITSIO error: $txt";
    return 0;
  }

  return 1;
}

# create the output file
sub write_spifits {

  # write everything
  #wfits cat($S, $b, $m)->mv(2,0)->float, $file;

  my ($file, $S, $b, $m, $dates, $factors) = @_;

  print STDERR "writing $file...";
  STDERR->flush;

  my $status=0;
  my $fptr = Astro::FITS::CFITSIO::create_file('!'.$file, $status);
  check_status($status) or die "error creating $file\n";

  # write "stacked" S_i, b_i and m_i as primary hdu
  my $img = cat($S, $b, $m)->mv(2,0)->double;
  $fptr->create_img(-64, $img->ndims, [$img->dims], $status);
  $fptr->write_pix(TDOUBLE, [(1)x$img->ndims], $img->nelem, $img->get_dataref, $status);
  $fptr->write_chksum($status);
  check_status($status) or die "error creating primary HDU in $file\n";

  # add binary table for gaindrop factors
  $fptr->create_tbl(BINARY_TBL, 0, 2,
		    ['date', 'dropcorr'],
		    ['1D', $factors->getdim(1).'D'],
		    undef,
		    'gaindrop',
		    $status);
  check_status($status) or die "error creating gaindrop HDU in $file\n";
  $_ = $_->double for $dates, $factors;
  $fptr->write_col(TDOUBLE, 1, 1, 1, $dates->nelem, $dates->get_dataref, $status);
  $fptr->write_col(TDOUBLE, 2, 1, 1, $factors->nelem, $factors->mv(0,1)->get_dataref, $status);
  $fptr->write_chksum($status);

  $fptr->close_file($status);
  check_status($status) or die "error closing $file\n";

  print STDERR "done\n";

}

sub unilluminated_fits {
  my $islope = +(shift)->copy; # illuminated slopes

  my $ams = Lab::active_mask_src();
  my $amb = Lab::active_mask_bg();

  # unilluminated subtaps
  my $umask = ($amb & !$ams);

  # read combined background
  $Lab::TYPE = 'samp';
  my $bg_hists = Lab::bg_hists();

  # set background data to zero except in unilluminated subtaps
  #($tmp = Lab::hists_indexND($bg_hists, scalar whichND(!$umask))) .= 0;
  my $bg_stat = $statfunc{$opts{stat}}->($bg_hists);

  # estimated average samp in unilluminated subtaps, based on background means
  my ($bgintercept, $bgslope) = @{$bgparams{$opts{stat}}}{'intercept', 'slope'};
  my $uS = ($bg_stat - $bgintercept) / $bgslope;

  # extend illuminated slopes to unilluminated subtaps via linear fits,

  # ideally the weights would include only the source mask subtaps
  # my $w = $ams->double;

  # but fitpoly1d doesn't like when all weights are zero (e.g., on
  # edges of detectors where all crsu are inactive), so instead use a
  # weighting scheme whereby the source mask are very large and the
  # rest of the detector is small
  my $w = ones(double, $ams->dims);
  (my $tmp = $w->where($ams)) .= 1e7;

  # make sure unilluminated slopes start with sane values
  ($tmp = $islope->where(!$ams)) .= 0;

  my $uslope = fitpoly1d(sequence($islope->getdim(0)), $islope, 2, {Weights => $w});

  # prescription for unilluminated intercepts, taken from Brad's
  # 2008-06-02 email, E = 500 eV

=begin comment

	116.5 = 113.32*(m_i*logE + b_i)		(for means)
	118.5 = 116.36*(m_i*logE + b_i)		(for medians).

=cut

#  my $uintercept = 116.5/113.32 - $uslope * log10(500.0);
  my $uintercept = $ufactor{$opts{stat}} - $uslope * log10(500.0);

  return $uS, $uintercept, $uslope, $umask;
}
