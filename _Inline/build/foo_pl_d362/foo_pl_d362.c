/*
 * This file was generated automatically by xsubpp version 1.9508 from the
 * contents of foo_pl_d362.xs. Do not edit this file, edit foo_pl_d362.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "foo_pl_d362.xs"

/*
 * THIS FILE WAS GENERATED BY PDL::PP! Do not modify!
 */
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#include "pdl.h"
#include "pdlcore.h"
static Core* PDL; /* Structure hold core C functions */
static int __pdl_debugging = 0;
static int __pdl_boundscheck = 0;
static SV* CoreSV;       /* Gets pointer to perl var holding core structure */

/* we need to handle croak ourserlves */
/* #undef croak
   #define croak barf
 */

#if ! 1
# define PP_INDTERM(max, at) at
#else
# define PP_INDTERM(max, at) (__pdl_boundscheck? PDL->safe_indterm(max,at, __FILE__, __LINE__) : at)
#endif


typedef struct pdl_shift_negs_struct {
		PDL_TRANS_START(1);
		pdl_thread  __pdlthread;PDL_Long  __inc_i_n;PDL_Long  __n_size;
		
		char __ddone; /* Dims done */
		} pdl_shift_negs_struct;

void pdl_shift_negs_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_shift_negs_struct *__privtrans = (pdl_shift_negs_struct *) __tr;
	
	{
	    int __creating[1];
__privtrans->__n_size = -1;
__creating[0] = 0;
 {
/* no RedoDimsCode */
}
 {
 static char *__parnames[] = {"i"};
		static int __realdims[] = {1};
		static char __funcname[] = "foo_pl_d362::shift_negs";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 1
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,1,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags);
		}
   if(((__privtrans->pdls[0]))->ndims < 1) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         barf("Error in shift_negs:" "Wrong dims\n");
      }
   }

{ /* convenience block */
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp && 
	      __privtrans->pdls[0]->hdrsv && 
	 (__privtrans->pdls[0]->state & PDL_HDRCPY) 
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef) 
    hdr_copy = &PL_sv_undef;
  else  {  /* Call the perl routine _hdr_copy... */
    int count;
    /* Call the perl routine PDL::_hdr_copy(hdrp) */
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1) 
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");
    
    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); /*Keep hdr_copy from vanishing during FREETMPS*/

    FREETMPS ;
    LEAVE ;


  } /* end of callback  block */

    if(hdr_copy != &PL_sv_undef) 
      SvREFCNT_dec(hdr_copy); /* make hdr_copy mortal again */
   } /* end of if(hdrp) block */
} /* end of conv. block */
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_i_n = 0; else
		 __privtrans->__inc_i_n = PDL_REPRINC(__privtrans->pdls[0],0); __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_shift_negs_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_shift_negs_struct *__privtrans = (pdl_shift_negs_struct *) __tr;
	
	{
	    pdl_shift_negs_struct *__copy
 			= malloc(sizeof(pdl_shift_negs_struct));PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_i_n=__copy->__inc_i_n;__copy->__n_size=__privtrans->__n_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_shift_negs_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_shift_negs_struct *__privtrans = (pdl_shift_negs_struct *) __tr;
	
	{
	    {register int __n_size = __privtrans->__n_size;
/* Start generic loop */

	switch(__privtrans->__datatype) { case -42: /* Warning eater */ {1;
	} break; case PDL_B: {
	PDL_Byte * i_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Byte * i_physdatap = ((PDL_Byte *)((__privtrans->pdls[0])->data));

	/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];i_datap += __offsp[0];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{register PDL_Long __inc_i_n = __privtrans->__inc_i_n;

int n_size = __privtrans->__n_size; {/* Open n */ register int n;
			for(n=0; n<(__n_size); n++) { if ((i_datap)[0+(__inc_i_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  < 0 && n!=n_size) { (i_datap)[0+(__inc_i_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  = 5; }} /* Close n */
}	/* THREADLOOPEND */
	 i_datap += __tinc0_0;

	 } i_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;

	} i_datap -= __tinc1_0 *
     				  __tdims1;
 i_datap -= __privtrans->__pdlthread.offs[0];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_S: {
	PDL_Short * i_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Short * i_physdatap = ((PDL_Short *)((__privtrans->pdls[0])->data));

	/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];i_datap += __offsp[0];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{register PDL_Long __inc_i_n = __privtrans->__inc_i_n;

int n_size = __privtrans->__n_size; {/* Open n */ register int n;
			for(n=0; n<(__n_size); n++) { if ((i_datap)[0+(__inc_i_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  < 0 && n!=n_size) { (i_datap)[0+(__inc_i_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  = 5; }} /* Close n */
}	/* THREADLOOPEND */
	 i_datap += __tinc0_0;

	 } i_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;

	} i_datap -= __tinc1_0 *
     				  __tdims1;
 i_datap -= __privtrans->__pdlthread.offs[0];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_US: {
	PDL_Ushort * i_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Ushort * i_physdatap = ((PDL_Ushort *)((__privtrans->pdls[0])->data));

	/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];i_datap += __offsp[0];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{register PDL_Long __inc_i_n = __privtrans->__inc_i_n;

int n_size = __privtrans->__n_size; {/* Open n */ register int n;
			for(n=0; n<(__n_size); n++) { if ((i_datap)[0+(__inc_i_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  < 0 && n!=n_size) { (i_datap)[0+(__inc_i_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  = 5; }} /* Close n */
}	/* THREADLOOPEND */
	 i_datap += __tinc0_0;

	 } i_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;

	} i_datap -= __tinc1_0 *
     				  __tdims1;
 i_datap -= __privtrans->__pdlthread.offs[0];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_L: {
	PDL_Long * i_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * i_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];i_datap += __offsp[0];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{register PDL_Long __inc_i_n = __privtrans->__inc_i_n;

int n_size = __privtrans->__n_size; {/* Open n */ register int n;
			for(n=0; n<(__n_size); n++) { if ((i_datap)[0+(__inc_i_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  < 0 && n!=n_size) { (i_datap)[0+(__inc_i_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  = 5; }} /* Close n */
}	/* THREADLOOPEND */
	 i_datap += __tinc0_0;

	 } i_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;

	} i_datap -= __tinc1_0 *
     				  __tdims1;
 i_datap -= __privtrans->__pdlthread.offs[0];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_LL: {
	PDL_LongLong * i_datap = ((PDL_LongLong *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_LongLong * i_physdatap = ((PDL_LongLong *)((__privtrans->pdls[0])->data));

	/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];i_datap += __offsp[0];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{register PDL_Long __inc_i_n = __privtrans->__inc_i_n;

int n_size = __privtrans->__n_size; {/* Open n */ register int n;
			for(n=0; n<(__n_size); n++) { if ((i_datap)[0+(__inc_i_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  < 0 && n!=n_size) { (i_datap)[0+(__inc_i_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  = 5; }} /* Close n */
}	/* THREADLOOPEND */
	 i_datap += __tinc0_0;

	 } i_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;

	} i_datap -= __tinc1_0 *
     				  __tdims1;
 i_datap -= __privtrans->__pdlthread.offs[0];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_F: {
	PDL_Float * i_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Float * i_physdatap = ((PDL_Float *)((__privtrans->pdls[0])->data));

	/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];i_datap += __offsp[0];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{register PDL_Long __inc_i_n = __privtrans->__inc_i_n;

int n_size = __privtrans->__n_size; {/* Open n */ register int n;
			for(n=0; n<(__n_size); n++) { if ((i_datap)[0+(__inc_i_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  < 0 && n!=n_size) { (i_datap)[0+(__inc_i_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  = 5; }} /* Close n */
}	/* THREADLOOPEND */
	 i_datap += __tinc0_0;

	 } i_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;

	} i_datap -= __tinc1_0 *
     				  __tdims1;
 i_datap -= __privtrans->__pdlthread.offs[0];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_D: {
	PDL_Double * i_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * i_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];i_datap += __offsp[0];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{register PDL_Long __inc_i_n = __privtrans->__inc_i_n;

int n_size = __privtrans->__n_size; {/* Open n */ register int n;
			for(n=0; n<(__n_size); n++) { if ((i_datap)[0+(__inc_i_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  < 0 && n!=n_size) { (i_datap)[0+(__inc_i_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  = 5; }} /* Close n */
}	/* THREADLOOPEND */
	 i_datap += __tinc0_0;

	 } i_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;

	} i_datap -= __tinc1_0 *
     				  __tdims1;
 i_datap -= __privtrans->__pdlthread.offs[0];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_shift_negs_free(pdl_trans *__tr ) {
	int __dim;
	pdl_shift_negs_struct *__privtrans = (pdl_shift_negs_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;
			}
			
	}
    }
    



static char pdl_shift_negs_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_shift_negs_vtable = {
		0,0, 1, 1, pdl_shift_negs_vtable_flags,
		pdl_shift_negs_redodims, pdl_shift_negs_readdata, NULL,
		pdl_shift_negs_free,NULL,NULL,pdl_shift_negs_copy,NULL,
		sizeof(pdl_shift_negs_struct),"pdl_shift_negs_vtable",
		NULL
	 };

typedef struct pdl_inc_struct {
		PDL_TRANS_START(2);
		pdl_thread  __pdlthread;
		
		char __ddone; /* Dims done */
		} pdl_inc_struct;

void pdl_inc_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_inc_struct *__privtrans = (pdl_inc_struct *) __tr;
	
	{
	    int __creating[2];
__creating[0] = 0;
__creating[1] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[1]);
 {
/* no RedoDimsCode */
}
 {
 static char *__parnames[] = {"i","o"};
		static int __realdims[] = {0,0};
		static char __funcname[] = "foo_pl_d362::inc";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 2
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,2,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags);
		}
if(!__creating[1]) {
} else {
 int dims[1]; /* Use ninds+1 to avoid smart (stupid) compilers */
 PDL->thread_create_parameter(&__privtrans->__pdlthread,1,dims,0);
}
{ /* convenience block */
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp && 
	      __privtrans->pdls[0]->hdrsv && 
	 (__privtrans->pdls[0]->state & PDL_HDRCPY) 
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp && 
	 !__creating[1] && 
     __privtrans->pdls[1]->hdrsv && 
	 (__privtrans->pdls[1]->state & PDL_HDRCPY) 
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef) 
    hdr_copy = &PL_sv_undef;
  else  {  /* Call the perl routine _hdr_copy... */
    int count;
    /* Call the perl routine PDL::_hdr_copy(hdrp) */
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1) 
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");
    
    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); /*Keep hdr_copy from vanishing during FREETMPS*/

    FREETMPS ;
    LEAVE ;


  } /* end of callback  block */

       if ( __privtrans->pdls[1]->hdrsv != hdrp ){
	 if( __privtrans->pdls[1]->hdrsv && __privtrans->pdls[1]->hdrsv != &PL_sv_undef)  
             SvREFCNT_dec( __privtrans->pdls[1]->hdrsv ); 
	 if( hdr_copy != &PL_sv_undef ) 
             SvREFCNT_inc(hdr_copy); 
	 __privtrans->pdls[1]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[1]->state |= PDL_HDRCPY;
    if(hdr_copy != &PL_sv_undef) 
      SvREFCNT_dec(hdr_copy); /* make hdr_copy mortal again */
   } /* end of if(hdrp) block */
} /* end of conv. block */
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_inc_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_inc_struct *__privtrans = (pdl_inc_struct *) __tr;
	
	{
	    pdl_inc_struct *__copy
 			= malloc(sizeof(pdl_inc_struct));PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_inc_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_inc_struct *__privtrans = (pdl_inc_struct *) __tr;
	
	{
	    {/* Start generic loop */

	switch(__privtrans->__datatype) { case -42: /* Warning eater */ {1;
	} break; case PDL_B: {
	PDL_Byte * i_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Byte * i_physdatap = ((PDL_Byte *)((__privtrans->pdls[0])->data));

	PDL_Byte * o_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Byte * o_physdatap = ((PDL_Byte *)((__privtrans->pdls[1])->data));

	/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];i_datap += __offsp[0];
o_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{
(o_datap)[0] /* ACCESS() */  = (i_datap)[0] /* ACCESS() */  + 1;
}	/* THREADLOOPEND */
	 i_datap += __tinc0_0;
o_datap += __tinc0_1;

	 } i_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
o_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} i_datap -= __tinc1_0 *
     				  __tdims1;o_datap -= __tinc1_1 *
     				  __tdims1;
 i_datap -= __privtrans->__pdlthread.offs[0];
o_datap -= __privtrans->__pdlthread.offs[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_S: {
	PDL_Short * i_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Short * i_physdatap = ((PDL_Short *)((__privtrans->pdls[0])->data));

	PDL_Short * o_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Short * o_physdatap = ((PDL_Short *)((__privtrans->pdls[1])->data));

	/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];i_datap += __offsp[0];
o_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{
(o_datap)[0] /* ACCESS() */  = (i_datap)[0] /* ACCESS() */  + 1;
}	/* THREADLOOPEND */
	 i_datap += __tinc0_0;
o_datap += __tinc0_1;

	 } i_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
o_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} i_datap -= __tinc1_0 *
     				  __tdims1;o_datap -= __tinc1_1 *
     				  __tdims1;
 i_datap -= __privtrans->__pdlthread.offs[0];
o_datap -= __privtrans->__pdlthread.offs[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_US: {
	PDL_Ushort * i_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Ushort * i_physdatap = ((PDL_Ushort *)((__privtrans->pdls[0])->data));

	PDL_Ushort * o_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Ushort * o_physdatap = ((PDL_Ushort *)((__privtrans->pdls[1])->data));

	/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];i_datap += __offsp[0];
o_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{
(o_datap)[0] /* ACCESS() */  = (i_datap)[0] /* ACCESS() */  + 1;
}	/* THREADLOOPEND */
	 i_datap += __tinc0_0;
o_datap += __tinc0_1;

	 } i_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
o_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} i_datap -= __tinc1_0 *
     				  __tdims1;o_datap -= __tinc1_1 *
     				  __tdims1;
 i_datap -= __privtrans->__pdlthread.offs[0];
o_datap -= __privtrans->__pdlthread.offs[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_L: {
	PDL_Long * i_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * i_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * o_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * o_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];i_datap += __offsp[0];
o_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{
(o_datap)[0] /* ACCESS() */  = (i_datap)[0] /* ACCESS() */  + 1;
}	/* THREADLOOPEND */
	 i_datap += __tinc0_0;
o_datap += __tinc0_1;

	 } i_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
o_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} i_datap -= __tinc1_0 *
     				  __tdims1;o_datap -= __tinc1_1 *
     				  __tdims1;
 i_datap -= __privtrans->__pdlthread.offs[0];
o_datap -= __privtrans->__pdlthread.offs[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_LL: {
	PDL_LongLong * i_datap = ((PDL_LongLong *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_LongLong * i_physdatap = ((PDL_LongLong *)((__privtrans->pdls[0])->data));

	PDL_LongLong * o_datap = ((PDL_LongLong *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_LongLong * o_physdatap = ((PDL_LongLong *)((__privtrans->pdls[1])->data));

	/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];i_datap += __offsp[0];
o_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{
(o_datap)[0] /* ACCESS() */  = (i_datap)[0] /* ACCESS() */  + 1;
}	/* THREADLOOPEND */
	 i_datap += __tinc0_0;
o_datap += __tinc0_1;

	 } i_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
o_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} i_datap -= __tinc1_0 *
     				  __tdims1;o_datap -= __tinc1_1 *
     				  __tdims1;
 i_datap -= __privtrans->__pdlthread.offs[0];
o_datap -= __privtrans->__pdlthread.offs[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_F: {
	PDL_Float * i_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Float * i_physdatap = ((PDL_Float *)((__privtrans->pdls[0])->data));

	PDL_Float * o_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Float * o_physdatap = ((PDL_Float *)((__privtrans->pdls[1])->data));

	/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];i_datap += __offsp[0];
o_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{
(o_datap)[0] /* ACCESS() */  = (i_datap)[0] /* ACCESS() */  + 1;
}	/* THREADLOOPEND */
	 i_datap += __tinc0_0;
o_datap += __tinc0_1;

	 } i_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
o_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} i_datap -= __tinc1_0 *
     				  __tdims1;o_datap -= __tinc1_1 *
     				  __tdims1;
 i_datap -= __privtrans->__pdlthread.offs[0];
o_datap -= __privtrans->__pdlthread.offs[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_D: {
	PDL_Double * i_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * i_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * o_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * o_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];i_datap += __offsp[0];
o_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{
(o_datap)[0] /* ACCESS() */  = (i_datap)[0] /* ACCESS() */  + 1;
}	/* THREADLOOPEND */
	 i_datap += __tinc0_0;
o_datap += __tinc0_1;

	 } i_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
o_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} i_datap -= __tinc1_0 *
     				  __tdims1;o_datap -= __tinc1_1 *
     				  __tdims1;
 i_datap -= __privtrans->__pdlthread.offs[0];
o_datap -= __privtrans->__pdlthread.offs[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_inc_free(pdl_trans *__tr ) {
	int __dim;
	pdl_inc_struct *__privtrans = (pdl_inc_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_inc_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_inc_vtable = {
		0,0, 1, 2, pdl_inc_vtable_flags,
		pdl_inc_redodims, pdl_inc_readdata, NULL,
		pdl_inc_free,NULL,NULL,pdl_inc_copy,NULL,
		sizeof(pdl_inc_struct),"pdl_inc_vtable",
		NULL
	 };

typedef struct pdl_tcumul_struct {
		PDL_TRANS_START(2);
		pdl_thread  __pdlthread;PDL_Long  __inc_in_n;PDL_Long  __n_size;
		
		char __ddone; /* Dims done */
		} pdl_tcumul_struct;

void pdl_tcumul_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_tcumul_struct *__privtrans = (pdl_tcumul_struct *) __tr;
	
	{
	    int __creating[2];
__privtrans->__n_size = -1;
__creating[0] = 0;
__creating[1] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[1]);
 {
/* no RedoDimsCode */
}
 {
 static char *__parnames[] = {"in","mul"};
		static int __realdims[] = {1,0};
		static char __funcname[] = "foo_pl_d362::tcumul";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 2
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,2,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags);
		}
   if(((__privtrans->pdls[0]))->ndims < 1) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         barf("Error in tcumul:" "Wrong dims\n");
      }
   }
if(!__creating[1]) {
} else {
 int dims[1]; /* Use ninds+1 to avoid smart (stupid) compilers */
 PDL->thread_create_parameter(&__privtrans->__pdlthread,1,dims,0);
}
{ /* convenience block */
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp && 
	      __privtrans->pdls[0]->hdrsv && 
	 (__privtrans->pdls[0]->state & PDL_HDRCPY) 
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp && 
	 !__creating[1] && 
     __privtrans->pdls[1]->hdrsv && 
	 (__privtrans->pdls[1]->state & PDL_HDRCPY) 
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef) 
    hdr_copy = &PL_sv_undef;
  else  {  /* Call the perl routine _hdr_copy... */
    int count;
    /* Call the perl routine PDL::_hdr_copy(hdrp) */
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1) 
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");
    
    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); /*Keep hdr_copy from vanishing during FREETMPS*/

    FREETMPS ;
    LEAVE ;


  } /* end of callback  block */

       if ( __privtrans->pdls[1]->hdrsv != hdrp ){
	 if( __privtrans->pdls[1]->hdrsv && __privtrans->pdls[1]->hdrsv != &PL_sv_undef)  
             SvREFCNT_dec( __privtrans->pdls[1]->hdrsv ); 
	 if( hdr_copy != &PL_sv_undef ) 
             SvREFCNT_inc(hdr_copy); 
	 __privtrans->pdls[1]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[1]->state |= PDL_HDRCPY;
    if(hdr_copy != &PL_sv_undef) 
      SvREFCNT_dec(hdr_copy); /* make hdr_copy mortal again */
   } /* end of if(hdrp) block */
} /* end of conv. block */
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_in_n = 0; else
		 __privtrans->__inc_in_n = PDL_REPRINC(__privtrans->pdls[0],0); __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_tcumul_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_tcumul_struct *__privtrans = (pdl_tcumul_struct *) __tr;
	
	{
	    pdl_tcumul_struct *__copy
 			= malloc(sizeof(pdl_tcumul_struct));PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_in_n=__copy->__inc_in_n;__copy->__n_size=__privtrans->__n_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_tcumul_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_tcumul_struct *__privtrans = (pdl_tcumul_struct *) __tr;
	
	{
	    {register int __n_size = __privtrans->__n_size;
/* Start generic loop */

	switch(__privtrans->__datatype) { case -42: /* Warning eater */ {1;
	} break; case PDL_B: {
	PDL_Byte * in_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Byte * in_physdatap = ((PDL_Byte *)((__privtrans->pdls[0])->data));

	PDL_Byte * mul_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Byte * mul_physdatap = ((PDL_Byte *)((__privtrans->pdls[1])->data));

	/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];in_datap += __offsp[0];
mul_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{register PDL_Long __inc_in_n = __privtrans->__inc_in_n;

(mul_datap)[0] /* ACCESS() */  = 1;
                          {/* Open n */ register int n;
			for(n=0; n<(__n_size); n++) {
                            (mul_datap)[0] /* ACCESS() */  *= (in_datap)[0+(__inc_in_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
                          }} /* Close n */
}	/* THREADLOOPEND */
	 in_datap += __tinc0_0;
mul_datap += __tinc0_1;

	 } in_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
mul_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} in_datap -= __tinc1_0 *
     				  __tdims1;mul_datap -= __tinc1_1 *
     				  __tdims1;
 in_datap -= __privtrans->__pdlthread.offs[0];
mul_datap -= __privtrans->__pdlthread.offs[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_S: {
	PDL_Short * in_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Short * in_physdatap = ((PDL_Short *)((__privtrans->pdls[0])->data));

	PDL_Short * mul_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Short * mul_physdatap = ((PDL_Short *)((__privtrans->pdls[1])->data));

	/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];in_datap += __offsp[0];
mul_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{register PDL_Long __inc_in_n = __privtrans->__inc_in_n;

(mul_datap)[0] /* ACCESS() */  = 1;
                          {/* Open n */ register int n;
			for(n=0; n<(__n_size); n++) {
                            (mul_datap)[0] /* ACCESS() */  *= (in_datap)[0+(__inc_in_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
                          }} /* Close n */
}	/* THREADLOOPEND */
	 in_datap += __tinc0_0;
mul_datap += __tinc0_1;

	 } in_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
mul_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} in_datap -= __tinc1_0 *
     				  __tdims1;mul_datap -= __tinc1_1 *
     				  __tdims1;
 in_datap -= __privtrans->__pdlthread.offs[0];
mul_datap -= __privtrans->__pdlthread.offs[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_US: {
	PDL_Ushort * in_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Ushort * in_physdatap = ((PDL_Ushort *)((__privtrans->pdls[0])->data));

	PDL_Ushort * mul_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Ushort * mul_physdatap = ((PDL_Ushort *)((__privtrans->pdls[1])->data));

	/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];in_datap += __offsp[0];
mul_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{register PDL_Long __inc_in_n = __privtrans->__inc_in_n;

(mul_datap)[0] /* ACCESS() */  = 1;
                          {/* Open n */ register int n;
			for(n=0; n<(__n_size); n++) {
                            (mul_datap)[0] /* ACCESS() */  *= (in_datap)[0+(__inc_in_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
                          }} /* Close n */
}	/* THREADLOOPEND */
	 in_datap += __tinc0_0;
mul_datap += __tinc0_1;

	 } in_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
mul_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} in_datap -= __tinc1_0 *
     				  __tdims1;mul_datap -= __tinc1_1 *
     				  __tdims1;
 in_datap -= __privtrans->__pdlthread.offs[0];
mul_datap -= __privtrans->__pdlthread.offs[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_L: {
	PDL_Long * in_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * in_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * mul_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mul_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];in_datap += __offsp[0];
mul_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{register PDL_Long __inc_in_n = __privtrans->__inc_in_n;

(mul_datap)[0] /* ACCESS() */  = 1;
                          {/* Open n */ register int n;
			for(n=0; n<(__n_size); n++) {
                            (mul_datap)[0] /* ACCESS() */  *= (in_datap)[0+(__inc_in_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
                          }} /* Close n */
}	/* THREADLOOPEND */
	 in_datap += __tinc0_0;
mul_datap += __tinc0_1;

	 } in_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
mul_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} in_datap -= __tinc1_0 *
     				  __tdims1;mul_datap -= __tinc1_1 *
     				  __tdims1;
 in_datap -= __privtrans->__pdlthread.offs[0];
mul_datap -= __privtrans->__pdlthread.offs[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_LL: {
	PDL_LongLong * in_datap = ((PDL_LongLong *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_LongLong * in_physdatap = ((PDL_LongLong *)((__privtrans->pdls[0])->data));

	PDL_LongLong * mul_datap = ((PDL_LongLong *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_LongLong * mul_physdatap = ((PDL_LongLong *)((__privtrans->pdls[1])->data));

	/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];in_datap += __offsp[0];
mul_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{register PDL_Long __inc_in_n = __privtrans->__inc_in_n;

(mul_datap)[0] /* ACCESS() */  = 1;
                          {/* Open n */ register int n;
			for(n=0; n<(__n_size); n++) {
                            (mul_datap)[0] /* ACCESS() */  *= (in_datap)[0+(__inc_in_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
                          }} /* Close n */
}	/* THREADLOOPEND */
	 in_datap += __tinc0_0;
mul_datap += __tinc0_1;

	 } in_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
mul_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} in_datap -= __tinc1_0 *
     				  __tdims1;mul_datap -= __tinc1_1 *
     				  __tdims1;
 in_datap -= __privtrans->__pdlthread.offs[0];
mul_datap -= __privtrans->__pdlthread.offs[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_F: {
	PDL_Float * in_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Float * in_physdatap = ((PDL_Float *)((__privtrans->pdls[0])->data));

	PDL_Float * mul_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Float * mul_physdatap = ((PDL_Float *)((__privtrans->pdls[1])->data));

	/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];in_datap += __offsp[0];
mul_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{register PDL_Long __inc_in_n = __privtrans->__inc_in_n;

(mul_datap)[0] /* ACCESS() */  = 1;
                          {/* Open n */ register int n;
			for(n=0; n<(__n_size); n++) {
                            (mul_datap)[0] /* ACCESS() */  *= (in_datap)[0+(__inc_in_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
                          }} /* Close n */
}	/* THREADLOOPEND */
	 in_datap += __tinc0_0;
mul_datap += __tinc0_1;

	 } in_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
mul_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} in_datap -= __tinc1_0 *
     				  __tdims1;mul_datap -= __tinc1_1 *
     				  __tdims1;
 in_datap -= __privtrans->__pdlthread.offs[0];
mul_datap -= __privtrans->__pdlthread.offs[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_D: {
	PDL_Double * in_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * in_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * mul_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * mul_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];in_datap += __offsp[0];
mul_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{register PDL_Long __inc_in_n = __privtrans->__inc_in_n;

(mul_datap)[0] /* ACCESS() */  = 1;
                          {/* Open n */ register int n;
			for(n=0; n<(__n_size); n++) {
                            (mul_datap)[0] /* ACCESS() */  *= (in_datap)[0+(__inc_in_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
                          }} /* Close n */
}	/* THREADLOOPEND */
	 in_datap += __tinc0_0;
mul_datap += __tinc0_1;

	 } in_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
mul_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} in_datap -= __tinc1_0 *
     				  __tdims1;mul_datap -= __tinc1_1 *
     				  __tdims1;
 in_datap -= __privtrans->__pdlthread.offs[0];
mul_datap -= __privtrans->__pdlthread.offs[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_tcumul_free(pdl_trans *__tr ) {
	int __dim;
	pdl_tcumul_struct *__privtrans = (pdl_tcumul_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;
			}
			
	}
    }
    



static char pdl_tcumul_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_tcumul_vtable = {
		0,0, 1, 2, pdl_tcumul_vtable_flags,
		pdl_tcumul_redodims, pdl_tcumul_readdata, NULL,
		pdl_tcumul_free,NULL,NULL,pdl_tcumul_copy,NULL,
		sizeof(pdl_tcumul_struct),"pdl_tcumul_vtable",
		NULL
	 };



#line 1401 "foo_pl_d362.c"

XS(XS_foo_pl_d362_set_debugging); /* prototype to pass -Wmissing-prototypes */
XS(XS_foo_pl_d362_set_debugging)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: foo_pl_d362::set_debugging(i)");
    {
	int	i = (int)SvIV(ST(0));
	int	RETVAL;
	dXSTARG;
#line 1399 "foo_pl_d362.xs"
	RETVAL = __pdl_debugging;
	__pdl_debugging = i;
#line 1416 "foo_pl_d362.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_foo_pl_d362_set_boundscheck); /* prototype to pass -Wmissing-prototypes */
XS(XS_foo_pl_d362_set_boundscheck)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: foo_pl_d362::set_boundscheck(i)");
    {
	int	i = (int)SvIV(ST(0));
	int	RETVAL;
	dXSTARG;
#line 1408 "foo_pl_d362.xs"
       if (! 1)
         warn("Bounds checking is disabled for foo_pl_d362");
       RETVAL = __pdl_boundscheck;
       __pdl_boundscheck = i;
#line 1438 "foo_pl_d362.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_PDL_shift_negs); /* prototype to pass -Wmissing-prototypes */
XS(XS_PDL_shift_negs)
{
    dXSARGS;
   PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 1422 "foo_pl_d362.xs"
  char *objname = "PDL"; /* maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *i;
#line 1459 "foo_pl_d362.c"
#line 1429 "foo_pl_d362.xs"
{
  /* Check if you can get a package name for this input value.  It can be either a PDL (SVt_PVMG) or
     a hash which is a derived PDL subclass (SVt_PVHV) */
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  /* The package to bless output vars into is taken from the first input var */
  }
  if (items == 1) { /* all variables on stack, read in output and temp vars */
    nreturn = 0;
    i = PDL->SvPDLV(ST(0));
  }
  else if (items == 1) { /* only input variables on stack, create outputs and temps */
    nreturn = 0;
    i = PDL->SvPDLV(ST(0));
  }
  else {
    croak ("Usage:  PDL::shift_negs(i) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_shift_negs_struct  *__privtrans;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_shift_negs_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->__datatype = 0;if(__privtrans->__datatype < i->datatype) {
		 	__privtrans->__datatype = i->datatype;
		    }
if(__privtrans->__datatype == PDL_B) {}
else if(__privtrans->__datatype == PDL_S) {}
else if(__privtrans->__datatype == PDL_U) {}
else if(__privtrans->__datatype == PDL_L) {}
else if(__privtrans->__datatype == PDL_Q) {}
else if(__privtrans->__datatype == PDL_F) {}
else if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(__privtrans->__datatype != i->datatype) {
	     i = PDL->get_convertedpdl(i,__privtrans->__datatype);
	  }{}/* No flow: 0 */__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = i;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}
#line 1513 "foo_pl_d362.c"
	PUTBACK;
	return;
    }
}


XS(XS_PDL_inc); /* prototype to pass -Wmissing-prototypes */
XS(XS_PDL_inc)
{
    dXSARGS;
   PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 1485 "foo_pl_d362.xs"
  char *objname = "PDL"; /* maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *o_SV;
  pdl  *i;
  pdl  *o;
#line 1536 "foo_pl_d362.c"
#line 1494 "foo_pl_d362.xs"
{
  /* Check if you can get a package name for this input value.  It can be either a PDL (SVt_PVMG) or
     a hash which is a derived PDL subclass (SVt_PVHV) */
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  /* The package to bless output vars into is taken from the first input var */
  }
  if (items == 2) { /* all variables on stack, read in output and temp vars */
    nreturn = 0;
    i = PDL->SvPDLV(ST(0));
    o = PDL->SvPDLV(ST(1));
  }
  else if (items == 1) { /* only input variables on stack, create outputs and temps */
    nreturn = 1;
    i = PDL->SvPDLV(ST(0));
    if (strcmp(objname,"PDL") == 0) { /* shortcut if just PDL */
       o_SV = sv_newmortal();
       o = PDL->null();
       PDL->SetSV_PDL(o_SV,o);
       if (bless_stash) o_SV = sv_bless(o_SV, bless_stash);
    } else {
       /* warn("possibly relying on deprecated automatic copy call in derived class
    ")
       warn("please modify your initialize method to avoid future problems
    ");
       */
       PUSHMARK(SP);
       XPUSHs(parent);
       PUTBACK;
       perl_call_method("copy", G_SCALAR);
       /* perl_call_method("initialize", G_SCALAR); */
       SPAGAIN;
       o_SV = POPs;
       PUTBACK;
       o = PDL->SvPDLV(o_SV);
    }
  }
  else {
    croak ("Usage:  PDL::inc(i,o) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_inc_struct  *__privtrans;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_inc_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->__datatype = 0;if(__privtrans->__datatype < i->datatype) {
		 	__privtrans->__datatype = i->datatype;
		    }
if(!((o->state & PDL_NOMYDIMS) &&
		       o->trans == NULL) && __privtrans->__datatype < o->datatype) {
		 	__privtrans->__datatype = o->datatype;
		    }
if(__privtrans->__datatype == PDL_B) {}
else if(__privtrans->__datatype == PDL_S) {}
else if(__privtrans->__datatype == PDL_U) {}
else if(__privtrans->__datatype == PDL_L) {}
else if(__privtrans->__datatype == PDL_Q) {}
else if(__privtrans->__datatype == PDL_F) {}
else if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(__privtrans->__datatype != i->datatype) {
	     i = PDL->get_convertedpdl(i,__privtrans->__datatype);
	  }if( (o->state & PDL_NOMYDIMS) && o->trans == NULL ) {
	     o->datatype = __privtrans->__datatype;
	  } else if(__privtrans->__datatype != o->datatype) {
	     o = PDL->get_convertedpdl(o,__privtrans->__datatype);
	  }{}/* No flow: 0 */__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = i;
__privtrans->pdls[1] = o;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = o_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}
#line 1622 "foo_pl_d362.c"
	PUTBACK;
	return;
    }
}


XS(XS_PDL_tcumul); /* prototype to pass -Wmissing-prototypes */
XS(XS_PDL_tcumul)
{
    dXSARGS;
   PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 1582 "foo_pl_d362.xs"
  char *objname = "PDL"; /* maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *mul_SV;
  pdl  *in;
  pdl  *mul;
#line 1645 "foo_pl_d362.c"
#line 1591 "foo_pl_d362.xs"
{
  /* Check if you can get a package name for this input value.  It can be either a PDL (SVt_PVMG) or
     a hash which is a derived PDL subclass (SVt_PVHV) */
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  /* The package to bless output vars into is taken from the first input var */
  }
  if (items == 2) { /* all variables on stack, read in output and temp vars */
    nreturn = 0;
    in = PDL->SvPDLV(ST(0));
    mul = PDL->SvPDLV(ST(1));
  }
  else if (items == 1) { /* only input variables on stack, create outputs and temps */
    nreturn = 1;
    in = PDL->SvPDLV(ST(0));
    if (strcmp(objname,"PDL") == 0) { /* shortcut if just PDL */
       mul_SV = sv_newmortal();
       mul = PDL->null();
       PDL->SetSV_PDL(mul_SV,mul);
       if (bless_stash) mul_SV = sv_bless(mul_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       mul_SV = POPs;
       PUTBACK;
       mul = PDL->SvPDLV(mul_SV);
    }
  }
  else {
    croak ("Usage:  PDL::tcumul(in,mul) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_tcumul_struct  *__privtrans;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_tcumul_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->__datatype = 0;if(__privtrans->__datatype < in->datatype) {
		 	__privtrans->__datatype = in->datatype;
		    }
if(!((mul->state & PDL_NOMYDIMS) &&
		       mul->trans == NULL) && __privtrans->__datatype < mul->datatype) {
		 	__privtrans->__datatype = mul->datatype;
		    }
if(__privtrans->__datatype == PDL_B) {}
else if(__privtrans->__datatype == PDL_S) {}
else if(__privtrans->__datatype == PDL_U) {}
else if(__privtrans->__datatype == PDL_L) {}
else if(__privtrans->__datatype == PDL_Q) {}
else if(__privtrans->__datatype == PDL_F) {}
else if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(__privtrans->__datatype != in->datatype) {
	     in = PDL->get_convertedpdl(in,__privtrans->__datatype);
	  }if( (mul->state & PDL_NOMYDIMS) && mul->trans == NULL ) {
	     mul->datatype = __privtrans->__datatype;
	  } else if(__privtrans->__datatype != mul->datatype) {
	     mul = PDL->get_convertedpdl(mul,__privtrans->__datatype);
	  }{}/* No flow: 0 */__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = in;
__privtrans->pdls[1] = mul;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = mul_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}
#line 1725 "foo_pl_d362.c"
	PUTBACK;
	return;
    }
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_foo_pl_d362); /* prototype to pass -Wmissing-prototypes */
XS(boot_foo_pl_d362)
{
    dXSARGS;
    char* file = __FILE__;

    XS_VERSION_BOOTCHECK ;

        newXSproto("foo_pl_d362::set_debugging", XS_foo_pl_d362_set_debugging, file, "$");
        newXSproto("foo_pl_d362::set_boundscheck", XS_foo_pl_d362_set_boundscheck, file, "$");
        newXSproto("PDL::shift_negs", XS_PDL_shift_negs, file, ";@");
        newXSproto("PDL::inc", XS_PDL_inc, file, ";@");
        newXSproto("PDL::tcumul", XS_PDL_tcumul, file, ";@");

    /* Initialisation Section */

#line 1672 "foo_pl_d362.xs"

   /* Get pointer to structure of core shared C routines */
   /* make sure PDL::Core is loaded */
   perl_require_pv("PDL::Core");
   CoreSV = perl_get_sv("PDL::SHARE",FALSE);  /* SV* value */
#ifndef aTHX_
#define aTHX_
#endif
   if (CoreSV==NULL)
     Perl_croak(aTHX_ "Can't load PDL::Core module");
   PDL = INT2PTR(Core*, SvIV( CoreSV ));  /* Core* value */
   if (PDL->Version != PDL_CORE_VERSION)
     Perl_croak(aTHX_ "foo_pl_d362 needs to be recompiled against the newly installed PDL");

#line 1765 "foo_pl_d362.c"

    /* End of Initialisation Section */

    XSRETURN_YES;
}

